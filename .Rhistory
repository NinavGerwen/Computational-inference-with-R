mean100[i] <- mean(Y)
mean10000[i] <- mean(Z)
}
# store the output in a list (separate elements of the list
# can be called with $ sign.)
list(mean5=mean5, mean100=mean100, mean10000=mean10000)
# Makes a boxplot of the three different sample sizes: 5, 100, 1000.
boxplot(mean5,mean100,mean10000,
names=c("n=5","n=100","n=10000"))
title("Distribution of Means from Normal Distribution")
}
SamplingMeanNorm(2, 1.2, 1000)
library(foreign)
library(ggplot2)
library(RColorBrewer)
cols <- brewer.pal(11, "RdBu")
cols
therapy_data <- read.spss("therapy_LONG.sav", to.data.frame = TRUE)
mean_per_two_factors <- aggregate(x = therapy_data$anxiety, by = list(therapy_data$cond, therapy_data$time), FUN = mean)
variance_per_two_factors <- aggregate(x = therapy_data$anxiety, by = list(therapy_data$cond, therapy_data$time), FUN = var)
total_data <- cbind(mean_per_two_factors, variance_per_two_factors$x)
## Calculate the standard error for every group on every phase
total_data$se <- sqrt(total_data$`variance_per_two_factors$x`) / sqrt(30)
Profile_Plot <- ggplot(data = total_data, aes(x = Group.2, y = x, group = Group.1, colour = Group.1)) +
## create points for estimations for each group
geom_point(shape = 18, size = 2) +
## create a line between all point estimations for each group
geom_line(linetype = "longdash") +
## create an interval for every point estimation in the graph through geom_errorbar
geom_errorbar(aes(ymin = x - 1.96*se, ymax = x + 1.96*se), width = .1) +
## apply every possible label to the graph, including legend label
labs(x = "Phase", y = "Anxiety", title = "Figure 1", subtitle = "Anxiety as a function of time for two conditions", color = "Condition") +
## inverse the labels for the conditions in the legend
guides(color = guide_legend(reverse = TRUE)) +
## change the colours and labels for the different conditions and apply a general theme
scale_colour_manual(values = c("#2166AC", "#B2182B"), labels = c("Control", "Group Therapy")) + theme_bw() +
## position the legend on the top-right outside of the graph
theme(legend.justification = "top", plot.title = element_text(face = "bold"), plot.subtitle = element_text(face = "italic")) +
## change the labels on the x-axis
scale_x_discrete(limits = c("pretest", "posttest", "followup"), labels = c("Pretest", "Posttest", "Follow-up"))
Profile_Plot
library(tidyverse)
library(tidyverse)
data <- data(storms)
force(storms)
# To find all storms that occured in june: filter the data set for which the month is 6
filter(data, month == 6)
library(tidyverse)
data <- data(storms)
data <- data(storms)
force(storms)
storms <- data(storms)
library(tidyverse)
data <- data(storms)
force(storms)
data(storms)
force(storms)
library(tidyverse)
data(storms)
force(storms)
data(storms)
A.1:
```{r}
# To find all storms that occured in june: filter the data set for which the month is 6
filter(storms, month == 6)
rm(data)
# To find all storms that occured in june: filter the data set for which the month is 6
filter(storms, month == 6)
# Repeat for storms that occured in april (month == 4) OR (|) may (month == 5)
filter(storms, month == 4 | month == 5)
# To find the storms that occured on a specific day: specify the month AND (&) the day
filter(storms, month == 5 & day == 30)
# To find the storms between may 1st and 15th, specify month == 5 and day within (%in%) 1:15
filter(storms, month == 5 & day %in% c(1:15))
# Arrange the dataset storms by year, months and day (in this order)
arrange(storms, year, month, day)
# Repeat for storms that occured in april (month == 4) OR (|) may (month == 5)
filter(storms, month == 4 | month == 5)
# To find the storms that occured on a specific day: specify the month AND (&) the day
filter(storms, month == 5 & day == 30)
# To find the storms between may 1st and 15th, specify month == 5 and day within (%in%) 1:15
filter(storms, month == 5 & day %in% c(1:15))
# To find the storms between may 1st and 15th, specify month == 5 and day within (%in%) 1:15
filter(storms, month == 5 & day %in% c(1:15))
A.2:
```{r}
# Arrange the dataset storms by year, months and day (in this order)
arrange(storms, year, month, day)
```
A.3:
```{r}
# Arrange (same as sort) the dataset storm by ascending pressure and then by ascending latitude
arrange(storms, pressure, lat)
```
A.4:
```{r}
# S
select(storms, year:hour)
select(storms, !year:hour)
select(storms, !year:hour)
A.5:
```{r}
relocate(storms, name, category, wind)
```
A.6:
```{r}
# When selecting a variable name once:
select(storms, wind)
# When selecting a variable name multiple times:
select(storms, wind, wind, wind)
```
As you can see, nothing happens when you include the name of a variable multiple times in a select() call. It simply ignores the repetition.
A.7:
```{r}
select(data, year:day, wind, ends_with("diameter"))
```
# Exercise B: Diamonds
To start, load the correct package and dataset:
```{r}
library(ggplot2)
diamonds <- data(diamonds)
library(ggplot2)
diamonds <- data(diamonds)
data(diamonds)
force(diamonds)
View(diamonds)
diamonds %>% mutate(price_per_carat = price / carat)
diamonds %>% transmute(price_per_carat = price / carat)
View(diamonds)
diamonds %>% select(depth) %>% mean()
diamonds %>% select(depth) %>% mean(depth)
diamonds %>% select(diamonds, depth)
diamonds %>% select(depth)
diamonds %>% select(depth) %>% summarize(mean_depth = mean())
diamonds %>% select(depth) %>% summarize(mean_depth = mean(depth))
diamonds %>% summarize(mean_depth = mean(depth))
diamonds %>% group_by(cut) %>%
summarize(mean_depth = mean(depth),
range_depth = min(depth) & max(depth))
diamonds %>% group_by(cut) %>%
summarize(mean_depth = mean(depth),
min_depth = min(depth),
max_depth = max(depth),
var_depth = var(depth))
?aggregate
aggregate(diamonds, by = cut, FUN = mean)
aggregate(diamonds, by = cut, FUN = mean())
aggregate(diamonds$depth, by = diamonds$cut, FUN = mean())
?summary
## without pipe notation
levels(cut)
## without pipe notation
levels(diamonds$cut)
summary(diamonds$depth[diamonds$cut == "Fair"])
summary(diamonds$depth)
summary(diamonds$depth[diamonds$cut == "Fair"])
summary(diamonds$depth[diamonds$cut == "Good"])
summary(diamonds$depth[diamonds$cut == "Very Good"])
summary(diamonds$depth[diamonds$cut == "Premium"])
summary(diamonds$depth[diamonds$cut == "Ideal"])
diamonds %>% group_by(cut) %>%
summarize(mean_depth = mean(depth),
min_depth = min(depth),
max_depth = max(depth),
var_depth = var(depth))
?filter
diamonds %>% filter(color != "J" & color > 3000)
diamonds %>% filter(color != "J" & sum(color) > 3000)
diamonds %>% filter(color != "J" & length(color) > 3000)
length(color)
length(diamonds$color)
diamonds %>% filter(color != "J" & length(color[]) > 3000)
sum(diamonds$color)
length(colour["J"])
length(colour["E"])
length(diamonds$color["E"])
length(diamonds$color["E"])
length(diamonds$color[])
length(diamonds$color[J])
length(diamonds$color["D"])
length(diamonds$color == D)
length(diamonds$color == "D")
diamonds %>% filter(color != "J" & count(color) > 3000)
count(diamonds$color)
diamonds %>% count(colors)
diamonds %>% count(color)
diamonds %>% count(color > 3000)
diamonds %>% count(color)
diamonds %>% filter(color != "J" & count(color) > 3000)
length(diamonds$color)
diamonds %>% filter(count(color) > 3000)
diamonds %>% filter(color != "J" & length(color) > 3000)
count(diamonds$color)
count(diamonds$color)
count(diamonds, color)
diamonds %>% filter(length(color) > 3000)
diamonds %>% select(count(color) > 3000)
diamonds %>% select(count(color) > 3000)
diamonds %>% filter(count(color) > 3000)
diamonds %>%
group_by(color) %>%
filter(n() > 3000)
diamonds %>%
group_by(color) %>%
filter(n(color != J) > 3000)
diamonds %>%
group_by(color) %>%
filter(n() > 3000)
diamonds %>%
count(color) %>%
filter(n() > 3000)
count(diamonds, color) %>%
filter(n() > 3000)
diamonds %>%
group_by(color) %>%
filter(n() > 3000 & color == "J")
diamonds %>%
group_by(color) %>%
filter(n() > 3000)
diamonds %>%
group_by(color) %>%
filter(n() > 3000 | color == "J")
diamonds %>%
group_by(color) %>%
filter(n() > 3000 | color == "J") %>%
mutate(mean_price = mean(price),
mean_carat = mean(carat))
# To find all storms that occured in june: filter the data set for which the month is 6
filter(storms, month == 6)
# Repeat for storms that occured in april (month == 4) OR (|) may (month == 5)
filter(storms, month == 4 | month == 5)
# To find the storms that occured on a specific day: specify the month AND (&) the day
filter(storms, month == 5 & day == 30)
# To find the storms between may 1st and 15th, specify month == 5 and day within (%in%) 1:15
filter(storms, month == 5 & day %in% c(1:15))
# Arrange the dataset storms by year, months and day (in this order)
arrange(storms, year, month, day)
# Arrange (same as sort) the dataset storm by ascending pressure and then by ascending latitude
arrange(storms, pressure, lat)
# S
select(storms, year:hour)
select(storms, !year:hour)
relocate(storms, name, category, wind)
# When selecting a variable name once:
select(storms, wind)
# When selecting a variable name multiple times:
select(storms, wind, wind, wind)
select(data, year:day, wind, ends_with("diameter"))
select(storms, year:day, wind, ends_with("diameter"))
diamonds %>% mutate(price_per_carat = price / carat)
diamonds %>% transmute(price_per_carat = price / carat)
diamonds %>% summarize(mean_depth = mean(depth))
## with pipe notation
diamonds %>% group_by(cut) %>%
summarize(mean_depth = mean(depth),
min_depth = min(depth),
max_depth = max(depth),
var_depth = var(depth))
## without pipe notation
summary(diamonds$depth[diamonds$cut == "Fair"])
summary(diamonds$depth[diamonds$cut == "Good"])
summary(diamonds$depth[diamonds$cut == "Very Good"])
summary(diamonds$depth[diamonds$cut == "Premium"])
summary(diamonds$depth[diamonds$cut == "Ideal"])
diamonds %>%
group_by(color) %>%
filter(n() > 3000 | color == "J") %>%
mutate(mean_price = mean(price),
mean_carat = mean(carat))
count(diamonds, color)
diamonds %>%
group_by(color) %>%
filter(n() > 3000 | color == "J") %>%
mutate(mean_price = mean(price),
mean_carat = mean(carat))
# To find all storms that occured in june: filter the data set for which the month is 6
filter(storms, month == 6)
library(tidyverse)
data(storms)
force(storms)
# To find all storms that occured in june: filter the data set for which the month is 6
filter(storms, month == 6)
# Repeat for storms that occured in april (month == 4) OR (|) may (month == 5)
filter(storms, month == 4 | month == 5)
# To find the storms that occured on a specific day: specify the month AND (&) the day
filter(storms, month == 5 & day == 30)
# To find the storms between may 1st and 15th, specify month == 5 and day within (%in%) 1:15
filter(storms, month == 5 & day %in% c(1:15))
# Arrange the dataset storms by year, months and day (in this order)
arrange(storms, year, month, day)
# Arrange (same as sort) the dataset storm by ascending pressure and then by ascending latitude
arrange(storms, pressure, lat)
## to select two columns and all columns inbetween, specify the columns and put a : between them
select(storms, year:hour)
## to select all columns except two columns and all columns inbetween, add a ! before the specification
select(storms, !year:hour)
## to move variables to the beginning of the dataset, use relocate() and state the variables you want at the beginnin
relocate(storms, name, category, wind)
# When selecting a variable name once:
select(storms, wind)
# When selecting a variable name multiple times:
select(storms, wind, wind, wind)
## use select() and state the three expressions on which the columns must be selected:
select(storms, year:day, wind, ends_with("diameter"))
library(ggplot2)
data(diamonds)
## to make a new variable and add it to the dataset, use the mutate variable
## in which you state what the new variable has to be: in this case, it has to be price divided by carat
diamonds %>% mutate(price_per_carat = price / carat)
## to only keep the new variable and lose the other variables in the dataset, use transmute() instead of mutate()
diamonds %>% transmute(price_per_carat = price / carat)
## to gain the mean depth, select the dataset, then use the summarize() command and specify the mean() function of depth
diamonds %>% summarize(mean_depth = mean(depth))
## with pipe notation
## with the pipe notation, you first select the dataset, then you group by the quality of the cut
## and finally you summarize through the summarize() command and specify all the information (mean, range, etc.) you want in this command
diamonds %>% group_by(cut) %>%
summarize(mean_depth = mean(depth),
min_depth = min(depth),
max_depth = max(depth),
var_depth = var(depth))
## without pipe notation
## without pipe notation, summarizing depth by quality of cut is done by asking for the summary() function while
## selecting all elements in a certain category of cut through a boolean expression
summary(diamonds$depth[diamonds$cut == "Fair"])
summary(diamonds$depth[diamonds$cut == "Good"])
summary(diamonds$depth[diamonds$cut == "Very Good"])
summary(diamonds$depth[diamonds$cut == "Premium"])
summary(diamonds$depth[diamonds$cut == "Ideal"])
## first, state the correct dataset
diamonds %>%
## then, group by the colour variable
group_by(color) %>%
## on the variable colour, filter only the categories for which there are more than 3000 observations OR the colour category "J"
filter(n() > 3000 | color == "J") %>%
## create a new variable through mutate that gives the mean price and mean carat per colour category
mutate(mean_price = mean(price),
mean_carat = mean(carat))
rm(diamonds, storms)
library(tidyverse)
library(tidyverse)
vet_data <- read_csv("vet.data.csv")
vet_data <- vet_data %>%
pivot_wider(names_from = type, values_from = c(value2017, value2018)) %>%
separate(gen_age, into = c("Gender", "Age"), sep = "_")
str(vet_data)
vet_data$client <- as.character(vet_data$client)
vet_data$food_quality <- as.factor(vet_data$food_quality)
vet_data$clinic <- as.factor(vet_data$clinic)
vet_data$Gender <- as.factor(vet_data$Gender)
vet_data$breed <- as.factor(vet_data$breed)
vet_data$area <- as.factor(vet_data$area)
vet_data$Age <- as.numeric(vet_data$Age)
str(vet_data)
View(vet_data)
?pivot_wider
?str
par(mfrow=c(2,2))
hist(vet_data$breed)
plot(vet_data$breed)
barplot(vet_data$breed)
plot(vet_data$breed)
plot(vet_data$food_quality)
plot(vet_data$area)
library(ggplot2)
weight_conditional_on_breed <- ggplot(vet_data, aes(value2017_weight, colour = breed)) + geom_histogram()
weight_conditional_on_breed
weight_conditional_on_breed <- ggplot(vet_data, aes(value2017_weight, colour = breed)) + geom_point()
weight_conditional_on_breed
weight_conditional_on_breed <- ggplot(vet_data, aes(value2017_weight, colour = breed)) + geom_bar()
weight_conditional_on_breed
weight_conditional_on_breed <- ggplot(vet_data, aes(y =value2017_weight, colour = breed)) + geom_bar()
weight_conditional_on_breed
ggplot(vet_data, aes(x = breed, y = value2017_weight, colour = breed)) + geom_boxplot()
plot(vet_data$breed)
plot(vet_data$food_quality)
plot(vet_data$area)
ggplot(vet_data, aes(x = breed, y = value2017_weight, colour = breed)) + geom_boxplot()
## the breed with lowest mean weight is the persian cat, the cat with the highest observed weight is an american shorthair
vet_data %>%
group_by(clinic) %>%
group_by(Gender) %>%
summarize(mean(value2017_weight), mean(value2018_weight))
## look at the internal structure again and check if everything is correct
str(vet_data)
vet_data %>%
group_by(clinic & Gender)
vet_data %>%
group_by(clinic, Gender)
vet_data %>%
group_by(clinic, Gender)
vet_data %>%
group_by(clinic, Gender) %>%
summarize(mean(value2017_weight), mean(value2018_weight))
vet_data %>%
filter(value2017_weight < 2.5 | value2018_weight < 2.5)
select(!c(value2017_weight, value2018_weight)
vet_data %>%
vet_data %>%
mutate(value2017_kg = value2017_weight/2.05) %>%
mutate(value2018_kg = value2018_weight/2.05) %>%
select(!value2017_weight) %>%
select(!value2018_weight)
ggplot(vet_data, aes(x = area, y = feed)) + geom_tile()
ggplot(vet_data, aes(x = area, y = food_quality)) + geom_tile()
tidy.vet.data %>%
count(area, food_quality) %>%
ggplot(aes(x=area, y=food_quality)) +
geom_tile(aes(fill=n))
vet_data %>%
count(area, food_quality) %>%
ggplot(aes(x=area, y=food_quality)) +
geom_tile(aes(fill=n))
vet_data %>%
count(area, food_quality) %>%
ggplot(aes(area, food_quality)) +
geom_tile()
vet_data %>%
count(area, food_quality) %>%
ggplot(aes(area, food_quality)) +
geom_tile(aes(fill=x))
vet_data %>%
count(area, food_quality) %>%
ggplot(aes(area, food_quality)) +
geom_tile(aes(fill=count(area, food_quality)))
vet_data %>%
ggplot(aes(area, food_quality)) +
geom_tile(aes(fill=count(area, food_quality)))
vet_data %>%
count(area, food_quality) %>%
ggplot(aes(area, food_quality)) +
geom_tile(aes(fill=n))
vet_data %>%
## filter the values
filter(!value2017_weight < 2.5 | value2018_weight < 2.5)
vet_data %>%
filter(value2017_weight < 2.5 | value2018_weight < 2.5)
vet_data %>%
## filter the values where the weight values are below 2.5
filter(!value2017_weight < 2.5 | !value2018_weight < 2.5)
count()
?count
library(tidyverse)
library(ggplot2)
vet_data <- read_csv("vet.data.csv")
## to tidy the dataset
vet_data <- vet_data %>%
## increase the number of columns by making columns of the two types of weigh ('type') and the values from the 2017 and 2018 value columns
pivot_wider(names_from = type, values_from = c(value2017, value2018)) %>%
## seperate the gender and age variable in two different columns
separate(gen_age, into = c("Gender", "Age"), sep = "_")
## look at the internal structure of the dataframe/tibble
str(vet_data)
## when checking the internal structure, I find that a lot of the data types are wrong, so I recode them into the correct type
vet_data$client <- as.character(vet_data$client)
vet_data$food_quality <- as.factor(vet_data$food_quality)
vet_data$clinic <- as.factor(vet_data$clinic)
vet_data$Gender <- as.factor(vet_data$Gender)
vet_data$breed <- as.factor(vet_data$breed)
vet_data$area <- as.factor(vet_data$area)
vet_data$Age <- as.numeric(vet_data$Age)
## look at the internal structure again and check if everything is correct
str(vet_data)
library(tidyverse)
library(ggplot2)
vet_data <- read_csv("vet.data.csv")
## to tidy the dataset
vet_data <- vet_data %>%
## increase the number of columns by making columns of the two types of weigh ('type') and the values from the 2017 and 2018 value columns
pivot_wider(names_from = type, values_from = c(value2017, value2018)) %>%
## seperate the gender and age variable in two different columns
separate(gen_age, into = c("Gender", "Age"), sep = "_")
## look at the internal structure of the dataframe/tibble
str(vet_data)
## when checking the internal structure, I find that a lot of the data types are wrong, so I recode them into the correct type
vet_data$client <- as.character(vet_data$client)
vet_data$food_quality <- as.factor(vet_data$food_quality)
vet_data$clinic <- as.factor(vet_data$clinic)
vet_data$Gender <- as.factor(vet_data$Gender)
vet_data$breed <- as.factor(vet_data$breed)
vet_data$area <- as.factor(vet_data$area)
vet_data$Age <- as.numeric(vet_data$Age)
## look at the internal structure again and check if everything is correct
str(vet_data)
plot(vet_data$breed)
plot(vet_data$food_quality)
plot(vet_data$area)
ggplot(vet_data, aes(x = breed, y = value2017_weight, colour = breed)) + geom_boxplot()
## the breed with lowest mean weight is the persian cat, the cat with the highest observed weight is an american shorthair for the 2017 values
vet_data %>%
## group by these two variables
group_by(clinic, Gender) %>%
## then summarize and give the mean of both weight values
summarize(mean(value2017_weight), mean(value2018_weight))
vet_data %>%
## filter the values where the weight values are below 2.5
filter(!value2017_weight < 2.5 | !value2018_weight < 2.5)
## the unique client ID's that have been influenced are client 16 on clinic 7, client 12 on clinic 9 and client 17 on clinic 13
vet_data %>%
## turn both values from lbs to kgs
mutate(value2017_kg = value2017_weight/2.05) %>%
mutate(value2018_kg = value2018_weight/2.05) %>%
## select all columns that are not the old weight columns
select(!value2017_weight) %>%
select(!value2018_weight)
vet_data %>%
## count the unique values of the two combinations
count(area, food_quality) %>%
## create a ggplot with the correct dimensions
ggplot(aes(area, food_quality)) +
## state that we want a geom_tile() which is filled with colours based on the number of unique values of the two combinations
geom_tile(aes(fill=n))
