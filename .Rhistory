SamplingMeanNorm <- function(mu, sigma, numsim){
# create memory for the sampled values for the three different sample sizes
mean5 <- rep(0,numsim)
mean100 <- rep(0,numsim)
mean10000 <- rep(0,numsim)
# fill in the missing part here
# use rnorm (for n, with mean and sd, give n values)
# and for loop
for(i in 1:numsim) {
X <- rnorm(5, mu, sigma)
Y <- rnorm(100, mu, sigma)
Z <- rnorm(10000, mu, sigma)
# now calculate the mean of these 3 things
# add that mean to respectively mean5/100/100000
mean5 <- mean(X)
mean100 <- mean(Y)
mean10000 <- mean(Z)
}
# store the output in a list (separate elements of the list
# can be called with $ sign.)
list(mean5=mean5, mean100=mean100, mean10000=mean10000)
# Makes a boxplot of the three different sample sizes: 5, 100, 1000.
boxplot(mean5,mean100,mean10000,
names=c("n=5","n=100","n=10000"))
title("Distribution of means from Normal distribution")
}
SamplingMeanNorm(2, 1.2, 1000)
SamplingMeanNorm <- function(mu, sigma, numsim){
# create memory for the sampled values for the three different sample sizes
mean5 <- rep(0,numsim)
mean100 <- rep(0,numsim)
mean10000 <- rep(0,numsim)
# fill in the missing part here
# use rnorm (for n, with mean and sd, give n values)
# and for loop
for(i in 1:numsim) {
X <- rnorm(5, mu, sigma)
Y <- rnorm(100, mu, sigma)
Z <- rnorm(10000, mu, sigma)
# now calculate the mean of these 3 things
# add that mean to respectively mean5/100/100000
mean5[i] <- mean(X)
mean100[i] <- mean(Y)
mean10000[i] <- mean(Z)
}
# store the output in a list (separate elements of the list
# can be called with $ sign.)
list(mean5=mean5, mean100=mean100, mean10000=mean10000)
# Makes a boxplot of the three different sample sizes: 5, 100, 1000.
boxplot(mean5,mean100,mean10000,
names=c("n=5","n=100","n=10000"))
title("Distribution of means from Normal distribution")
}
SamplingMeanNorm(2, 1.2, 1000)
title("Distribution of Means from Normal Distribution")
SamplingMeanNorm <- function(mu, sigma, numsim){
# create memory for the sampled values for the three different sample sizes
mean5 <- rep(0,numsim)
mean100 <- rep(0,numsim)
mean10000 <- rep(0,numsim)
# fill in the missing part here
# use rnorm (for n, with mean and sd, give n values)
# and for loop
for(i in 1:numsim) {
X <- rnorm(5, mu, sigma)
Y <- rnorm(100, mu, sigma)
Z <- rnorm(10000, mu, sigma)
# now calculate the mean of these 3 things
# add that mean to respectively mean5/100/100000
mean5[i] <- mean(X)
mean100[i] <- mean(Y)
mean10000[i] <- mean(Z)
}
# store the output in a list (separate elements of the list
# can be called with $ sign.)
list(mean5=mean5, mean100=mean100, mean10000=mean10000)
# Makes a boxplot of the three different sample sizes: 5, 100, 1000.
boxplot(mean5,mean100,mean10000,
names=c("n=5","n=100","n=10000"))
title("Distribution of Means from Normal Distribution")
}
mean5
SamplingMeanNorm(100, 15, 30)
SamplingMeanNorm(2, 1.2, 1000)
SamplingMeanNorm(2, 1.2, 1000)
SamplingMeanNorm(2, 1.2, 1000)
X = 5
Y = 2
(X + Y)/2
rm(list=())
rm(X, Y)
ComputeMedian(example.data)
example.data <- matrix(c(2,5,14,23,18,9,11), nrow=7, ncol=1)
data.problem <- matrix(c(1:8), 8, 1)
ComputeAllMedians <- function(data){
n <- length(data)
sorted.data <- sort(data)
if(n %% 2 != 0) {
median.value <- sorted.data[(n+1)/2]
list(median.value = median.value)
} else {
two.middle.elements <- sorted.data[c((n)/2, ((n)/2)+1)]
median.value <- two.middle.elements/2
list(median.value = median.value)
}
}
ComputeAllMedians(data.problem)
ComputeAllMedians <- function(data){
n <- length(data)
sorted.data <- sort(data)
if(n %% 2 != 0) {
median.value <- sorted.data[(n+1)/2]
list(median.value = median.value)
} else {
two.middle.elements <- sorted.data[c((n)/2, ((n)/2)+1)]
median.value <- (two.middle.elements)/2
list(median.value = median.value)
}
}
ComputeAllMedians(data.problem)
sum.two.middle.elements <- sum(sorted.data[c((n)/2, ((n)/2)+1)])
ComputeAllMedians <- function(data){
n <- length(data)
sorted.data <- sort(data)
if(n %% 2 != 0) {
median.value <- sorted.data[(n+1)/2]
list(median.value = median.value)
} else {
sum.two.middle.elements <- sum(sorted.data[c((n)/2, ((n)/2)+1)])
median.value <- (two.middle.elements)/2
list(median.value = median.value)
}
}
ComputeAllMedians(data.problem)
median.value <- sum.two.middle.elements/2
ComputeAllMedians <- function(data){
n <- length(data)
sorted.data <- sort(data)
if(n %% 2 != 0) {
median.value <- sorted.data[(n+1)/2]
list(median.value = median.value)
} else {
sum.two.middle.elements <- sum(sorted.data[c((n)/2, ((n)/2)+1)])
median.value <- sum.two.middle.elements/2
list(median.value = median.value)
}
}
ComputeAllMedians(data.problem)
ComputeAllMedians(example.data)
View(example.data)
ComputeAllMedians(c(1:10))
ComputeAllMedians(c(1:9))
median(data.problem)
# Now the function works for both odd and even numbered vectors!
ComputeAllMedians(data.problem) == median(data.problem)
ComputeAllMedians(example.data) == median(example.data)
# Now the function works for both odd and even numbered vectors!
ComputeAllMedians(data.problem) == median(data.problem)
ComputeAllMedians(example.data) == median(example.data)
?median
setwd("C:/Users/nina-/Documents/Master/Computational inference with R/")
SamplingMeanNorm <- function(mu, sigma, numsim){
# create memory for the sampled values for the three different sample sizes
mean5 <- rep(0,numsim)
mean100 <- rep(0,numsim)
mean10000 <- rep(0,numsim)
# create a for loop in which a variable i loops a total of 'numsim' times (which the user can specify)
for(i in 1:numsim) {
X <- rnorm(5, mu, sigma)        # create three new vectors that take respectively 5/100/100000 random values
Y <- rnorm(100, mu, sigma)      # from a normal probability with the mean and standard deviation
Z <- rnorm(10000, mu, sigma)    # specified by the user through rnorm()
# The next step is to calculate the mean of those three variables
# and add them to the correct memory base on the ith element
mean5[i] <- mean(X)
mean100[i] <- mean(Y)
mean10000[i] <- mean(Z)
}
# store the output in a list (separate elements of the list
# can be called with $ sign.)
list(mean5=mean5, mean100=mean100, mean10000=mean10000)
# Makes a boxplot of the three different sample sizes: 5, 100, 1000.
boxplot(mean5,mean100,mean10000,
names=c("n=5","n=100","n=10000"))
title("Distribution of Means from Normal Distribution")
}
SamplingMeanNorm(2, 1.2, 1000)
library(foreign)
library(ggplot2)
library(RColorBrewer)
cols <- brewer.pal(11, "RdBu")
cols
therapy_data <- read.spss("therapy_LONG.sav", to.data.frame = TRUE)
mean_per_two_factors <- aggregate(x = therapy_data$anxiety, by = list(therapy_data$cond, therapy_data$time), FUN = mean)
variance_per_two_factors <- aggregate(x = therapy_data$anxiety, by = list(therapy_data$cond, therapy_data$time), FUN = var)
total_data <- cbind(mean_per_two_factors, variance_per_two_factors$x)
## Calculate the standard error for every group on every phase
total_data$se <- sqrt(total_data$`variance_per_two_factors$x`) / sqrt(30)
Profile_Plot <- ggplot(data = total_data, aes(x = Group.2, y = x, group = Group.1, colour = Group.1)) +
## create points for estimations for each group
geom_point(shape = 18, size = 2) +
## create a line between all point estimations for each group
geom_line(linetype = "longdash") +
## create an interval for every point estimation in the graph through geom_errorbar
geom_errorbar(aes(ymin = x - 1.96*se, ymax = x + 1.96*se), width = .1) +
## apply every possible label to the graph, including legend label
labs(x = "Phase", y = "Anxiety", title = "Figure 1", subtitle = "Anxiety as a function of time for two conditions", color = "Condition") +
## inverse the labels for the conditions in the legend
guides(color = guide_legend(reverse = TRUE)) +
## change the colours and labels for the different conditions and apply a general theme
scale_colour_manual(values = c("#2166AC", "#B2182B"), labels = c("Control", "Group Therapy")) + theme_bw() +
## position the legend on the top-right outside of the graph
theme(legend.justification = "top", plot.title = element_text(face = "bold"), plot.subtitle = element_text(face = "italic")) +
## change the labels on the x-axis
scale_x_discrete(limits = c("pretest", "posttest", "followup"), labels = c("Pretest", "Posttest", "Follow-up"))
Profile_Plot
library(tidyverse)
library(tidyverse)
data <- data(storms)
force(storms)
# To find all storms that occured in june: filter the data set for which the month is 6
filter(data, month == 6)
library(tidyverse)
data <- data(storms)
data <- data(storms)
force(storms)
storms <- data(storms)
library(tidyverse)
data <- data(storms)
force(storms)
data(storms)
force(storms)
library(tidyverse)
data(storms)
force(storms)
data(storms)
A.1:
```{r}
# To find all storms that occured in june: filter the data set for which the month is 6
filter(storms, month == 6)
rm(data)
# To find all storms that occured in june: filter the data set for which the month is 6
filter(storms, month == 6)
# Repeat for storms that occured in april (month == 4) OR (|) may (month == 5)
filter(storms, month == 4 | month == 5)
# To find the storms that occured on a specific day: specify the month AND (&) the day
filter(storms, month == 5 & day == 30)
# To find the storms between may 1st and 15th, specify month == 5 and day within (%in%) 1:15
filter(storms, month == 5 & day %in% c(1:15))
# Arrange the dataset storms by year, months and day (in this order)
arrange(storms, year, month, day)
# Repeat for storms that occured in april (month == 4) OR (|) may (month == 5)
filter(storms, month == 4 | month == 5)
# To find the storms that occured on a specific day: specify the month AND (&) the day
filter(storms, month == 5 & day == 30)
# To find the storms between may 1st and 15th, specify month == 5 and day within (%in%) 1:15
filter(storms, month == 5 & day %in% c(1:15))
# To find the storms between may 1st and 15th, specify month == 5 and day within (%in%) 1:15
filter(storms, month == 5 & day %in% c(1:15))
A.2:
```{r}
# Arrange the dataset storms by year, months and day (in this order)
arrange(storms, year, month, day)
```
A.3:
```{r}
# Arrange (same as sort) the dataset storm by ascending pressure and then by ascending latitude
arrange(storms, pressure, lat)
```
A.4:
```{r}
# S
select(storms, year:hour)
select(storms, !year:hour)
select(storms, !year:hour)
A.5:
```{r}
relocate(storms, name, category, wind)
```
A.6:
```{r}
# When selecting a variable name once:
select(storms, wind)
# When selecting a variable name multiple times:
select(storms, wind, wind, wind)
```
As you can see, nothing happens when you include the name of a variable multiple times in a select() call. It simply ignores the repetition.
A.7:
```{r}
select(data, year:day, wind, ends_with("diameter"))
```
# Exercise B: Diamonds
To start, load the correct package and dataset:
```{r}
library(ggplot2)
diamonds <- data(diamonds)
library(ggplot2)
diamonds <- data(diamonds)
data(diamonds)
force(diamonds)
View(diamonds)
diamonds %>% mutate(price_per_carat = price / carat)
diamonds %>% transmute(price_per_carat = price / carat)
View(diamonds)
diamonds %>% select(depth) %>% mean()
diamonds %>% select(depth) %>% mean(depth)
diamonds %>% select(diamonds, depth)
diamonds %>% select(depth)
diamonds %>% select(depth) %>% summarize(mean_depth = mean())
diamonds %>% select(depth) %>% summarize(mean_depth = mean(depth))
diamonds %>% summarize(mean_depth = mean(depth))
diamonds %>% group_by(cut) %>%
summarize(mean_depth = mean(depth),
range_depth = min(depth) & max(depth))
diamonds %>% group_by(cut) %>%
summarize(mean_depth = mean(depth),
min_depth = min(depth),
max_depth = max(depth),
var_depth = var(depth))
?aggregate
aggregate(diamonds, by = cut, FUN = mean)
aggregate(diamonds, by = cut, FUN = mean())
aggregate(diamonds$depth, by = diamonds$cut, FUN = mean())
?summary
## without pipe notation
levels(cut)
## without pipe notation
levels(diamonds$cut)
summary(diamonds$depth[diamonds$cut == "Fair"])
summary(diamonds$depth)
summary(diamonds$depth[diamonds$cut == "Fair"])
summary(diamonds$depth[diamonds$cut == "Good"])
summary(diamonds$depth[diamonds$cut == "Very Good"])
summary(diamonds$depth[diamonds$cut == "Premium"])
summary(diamonds$depth[diamonds$cut == "Ideal"])
diamonds %>% group_by(cut) %>%
summarize(mean_depth = mean(depth),
min_depth = min(depth),
max_depth = max(depth),
var_depth = var(depth))
?filter
diamonds %>% filter(color != "J" & color > 3000)
diamonds %>% filter(color != "J" & sum(color) > 3000)
diamonds %>% filter(color != "J" & length(color) > 3000)
length(color)
length(diamonds$color)
diamonds %>% filter(color != "J" & length(color[]) > 3000)
sum(diamonds$color)
length(colour["J"])
length(colour["E"])
length(diamonds$color["E"])
length(diamonds$color["E"])
length(diamonds$color[])
length(diamonds$color[J])
length(diamonds$color["D"])
length(diamonds$color == D)
length(diamonds$color == "D")
diamonds %>% filter(color != "J" & count(color) > 3000)
count(diamonds$color)
diamonds %>% count(colors)
diamonds %>% count(color)
diamonds %>% count(color > 3000)
diamonds %>% count(color)
diamonds %>% filter(color != "J" & count(color) > 3000)
length(diamonds$color)
diamonds %>% filter(count(color) > 3000)
diamonds %>% filter(color != "J" & length(color) > 3000)
count(diamonds$color)
count(diamonds$color)
count(diamonds, color)
diamonds %>% filter(length(color) > 3000)
diamonds %>% select(count(color) > 3000)
diamonds %>% select(count(color) > 3000)
diamonds %>% filter(count(color) > 3000)
diamonds %>%
group_by(color) %>%
filter(n() > 3000)
diamonds %>%
group_by(color) %>%
filter(n(color != J) > 3000)
diamonds %>%
group_by(color) %>%
filter(n() > 3000)
diamonds %>%
count(color) %>%
filter(n() > 3000)
count(diamonds, color) %>%
filter(n() > 3000)
diamonds %>%
group_by(color) %>%
filter(n() > 3000 & color == "J")
diamonds %>%
group_by(color) %>%
filter(n() > 3000)
diamonds %>%
group_by(color) %>%
filter(n() > 3000 | color == "J")
diamonds %>%
group_by(color) %>%
filter(n() > 3000 | color == "J") %>%
mutate(mean_price = mean(price),
mean_carat = mean(carat))
# To find all storms that occured in june: filter the data set for which the month is 6
filter(storms, month == 6)
# Repeat for storms that occured in april (month == 4) OR (|) may (month == 5)
filter(storms, month == 4 | month == 5)
# To find the storms that occured on a specific day: specify the month AND (&) the day
filter(storms, month == 5 & day == 30)
# To find the storms between may 1st and 15th, specify month == 5 and day within (%in%) 1:15
filter(storms, month == 5 & day %in% c(1:15))
# Arrange the dataset storms by year, months and day (in this order)
arrange(storms, year, month, day)
# Arrange (same as sort) the dataset storm by ascending pressure and then by ascending latitude
arrange(storms, pressure, lat)
# S
select(storms, year:hour)
select(storms, !year:hour)
relocate(storms, name, category, wind)
# When selecting a variable name once:
select(storms, wind)
# When selecting a variable name multiple times:
select(storms, wind, wind, wind)
select(data, year:day, wind, ends_with("diameter"))
select(storms, year:day, wind, ends_with("diameter"))
diamonds %>% mutate(price_per_carat = price / carat)
diamonds %>% transmute(price_per_carat = price / carat)
diamonds %>% summarize(mean_depth = mean(depth))
## with pipe notation
diamonds %>% group_by(cut) %>%
summarize(mean_depth = mean(depth),
min_depth = min(depth),
max_depth = max(depth),
var_depth = var(depth))
## without pipe notation
summary(diamonds$depth[diamonds$cut == "Fair"])
summary(diamonds$depth[diamonds$cut == "Good"])
summary(diamonds$depth[diamonds$cut == "Very Good"])
summary(diamonds$depth[diamonds$cut == "Premium"])
summary(diamonds$depth[diamonds$cut == "Ideal"])
diamonds %>%
group_by(color) %>%
filter(n() > 3000 | color == "J") %>%
mutate(mean_price = mean(price),
mean_carat = mean(carat))
count(diamonds, color)
diamonds %>%
group_by(color) %>%
filter(n() > 3000 | color == "J") %>%
mutate(mean_price = mean(price),
mean_carat = mean(carat))
# To find all storms that occured in june: filter the data set for which the month is 6
filter(storms, month == 6)
library(tidyverse)
data(storms)
force(storms)
# To find all storms that occured in june: filter the data set for which the month is 6
filter(storms, month == 6)
# Repeat for storms that occured in april (month == 4) OR (|) may (month == 5)
filter(storms, month == 4 | month == 5)
# To find the storms that occured on a specific day: specify the month AND (&) the day
filter(storms, month == 5 & day == 30)
# To find the storms between may 1st and 15th, specify month == 5 and day within (%in%) 1:15
filter(storms, month == 5 & day %in% c(1:15))
# Arrange the dataset storms by year, months and day (in this order)
arrange(storms, year, month, day)
# Arrange (same as sort) the dataset storm by ascending pressure and then by ascending latitude
arrange(storms, pressure, lat)
## to select two columns and all columns inbetween, specify the columns and put a : between them
select(storms, year:hour)
## to select all columns except two columns and all columns inbetween, add a ! before the specification
select(storms, !year:hour)
## to move variables to the beginning of the dataset, use relocate() and state the variables you want at the beginnin
relocate(storms, name, category, wind)
# When selecting a variable name once:
select(storms, wind)
# When selecting a variable name multiple times:
select(storms, wind, wind, wind)
## use select() and state the three expressions on which the columns must be selected:
select(storms, year:day, wind, ends_with("diameter"))
library(ggplot2)
data(diamonds)
## to make a new variable and add it to the dataset, use the mutate variable
## in which you state what the new variable has to be: in this case, it has to be price divided by carat
diamonds %>% mutate(price_per_carat = price / carat)
## to only keep the new variable and lose the other variables in the dataset, use transmute() instead of mutate()
diamonds %>% transmute(price_per_carat = price / carat)
## to gain the mean depth, select the dataset, then use the summarize() command and specify the mean() function of depth
diamonds %>% summarize(mean_depth = mean(depth))
## with pipe notation
## with the pipe notation, you first select the dataset, then you group by the quality of the cut
## and finally you summarize through the summarize() command and specify all the information (mean, range, etc.) you want in this command
diamonds %>% group_by(cut) %>%
summarize(mean_depth = mean(depth),
min_depth = min(depth),
max_depth = max(depth),
var_depth = var(depth))
## without pipe notation
## without pipe notation, summarizing depth by quality of cut is done by asking for the summary() function while
## selecting all elements in a certain category of cut through a boolean expression
summary(diamonds$depth[diamonds$cut == "Fair"])
summary(diamonds$depth[diamonds$cut == "Good"])
summary(diamonds$depth[diamonds$cut == "Very Good"])
summary(diamonds$depth[diamonds$cut == "Premium"])
summary(diamonds$depth[diamonds$cut == "Ideal"])
## first, state the correct dataset
diamonds %>%
## then, group by the colour variable
group_by(color) %>%
## on the variable colour, filter only the categories for which there are more than 3000 observations OR the colour category "J"
filter(n() > 3000 | color == "J") %>%
## create a new variable through mutate that gives the mean price and mean carat per colour category
mutate(mean_price = mean(price),
mean_carat = mean(carat))
