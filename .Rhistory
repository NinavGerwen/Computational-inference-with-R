}
## Question 4:
gala_data2 <- gala_data[, 1:4]
Regression_Function(data = gala_data2)
data.class(gala_data[, -1])
gala_data
data.class(gala_data[, -1])
as.matrix(gala_data[, -1])
data.class(as.matrix(gala_data[, -1]))
Regression_Function <- function(dataset, DV = dataset[, 1], IV = dataset[, 2:ncol(dataset)]) { ## question: how to allow IV to be any number of things
DV <- matrix(DV, nrow = nrow(dataset))
IV <- as.matrix(cbind(rep(1,nrow(dataset)), matrix(IV, nrow = nrow(dataset))))
## Descriptive statistics of data:
Sample_Size <- nrow(dataset)
DV_mean <- mean(DV)
IV_means <- as.matrix(apply(IV[,-1, drop = FALSE], 2, FUN = mean))
descriptive_statistics <- list(Sample_Size, DV_mean, IV_means)
names(descriptive_statistics) <- c("Sample Size", "Mean of the Dependent Variable", "Means of the Independent Variable(s)")
## Regression coefficients, predicted values and residuals using matrix algebra:
model_coefficients  <- (solve(t(IV) %*% IV)) %*% (t(IV) %*% DV)
predicted_values <- IV %*% model_coefficients
error_residuals <- DV - predicted_values
## Simple plot of predicted values against the residuals:
simple_plot <- plot(predicted_values, error_residuals)
list_of_information <- list(descriptive_statistics, model_coefficients, simple_plot)
names(list_of_information) <- c("Descriptive statistics", "Regression coefficients",
"Simple plot of predicted values against the residuals")
## Finally, the function should return the created list that holds all information
return(list_of_information)
}
## Running the function on the tortoise dataset, the coefficients match
Regression_Function(data = gala_data, DV = gala_data$Species, IV = c(gala_data$Area, gala_data$Elevation, gala_data$Endemics))
Regression_Function(data = gala_data2)
Ex <- cbind(rep(1,30), gala_data[, -1])
View(Ex)
data.class((Ex))
?as.matrix
Ex <- cbind(rep(1,30), gala_data[, -1])
Ex <- as.matrix(cbind(rep(1,30), gala_data[, -1]))
View(Ex)
?mapply
str(gala_data[, -1])
Regression_Function <- function(dataset, DV = dataset[, 1], IV = dataset[, 2:ncol(dataset)]) { ## question: how to allow IV to be any number of things
DV <- matrix(DV, nrow = nrow(dataset))
IV <- as.matrix(cbind(rep(1,nrow(dataset)), matrix(IV, nrow = nrow(dataset))))
## Descriptive statistics of data:
Sample_Size <- nrow(dataset)
DV_mean <- mean(DV)
IV_means <- as.matrix(apply(IV[,-1, drop = FALSE], 2, FUN = mean))
descriptive_statistics <- list(Sample_Size, DV_mean, IV_means)
names(descriptive_statistics) <- c("Sample Size", "Mean of the Dependent Variable", "Means of the Independent Variable(s)")
## Regression coefficients, predicted values and residuals using matrix algebra:
model_coefficients  <- (solve(t(IV) %*% IV)) %*% (t(IV) %*% DV)
predicted_values <- IV %*% model_coefficients
error_residuals <- DV - predicted_values
## Simple plot of predicted values against the residuals:
simple_plot <- plot(predicted_values, error_residuals)
list_of_information <- list(descriptive_statistics, model_coefficients, simple_plot)
names(list_of_information) <- c("Descriptive statistics", "Regression coefficients",
"Simple plot of predicted values against the residuals")
## Finally, the function should return the created list that holds all information
return(list_of_information)
}
## Running the function on the tortoise dataset, the coefficients match
Regression_Function(data = gala_data, DV = gala_data$Species, IV = c(gala_data$Area, gala_data$Elevation, gala_data$Endemics))
Regression_Function(data = gala_data2)
gala_data[, -1] %*% gala_data
str(gala_data[, -1])
data.class(gala_data[, -1])
as.matrix(gala_data[, -1]) %*% gala_data
as.matrix(gala_data[, -1]) %*% as.matrix(gala_data)
as.matrix(gala_data[, -1]) %*% as.matrix(gala_data[, -1])
as.matrix(gala_data[, -1]) %*% as.matrix(t(gala_data[, -1]))
Regression_Function <- function(dataset, DV = dataset[, 1], IV = dataset[, 2:ncol(dataset)]) { ## question: how to allow IV to be any number of things
DV <- matrix(DV, nrow = nrow(dataset))
IV <- as.matrix(cbind(rep(1,nrow(dataset)), matrix(IV, nrow = nrow(dataset))))
## Descriptive statistics of data:
Sample_Size <- nrow(dataset)
DV_mean <- mean(DV)
IV_means <- as.matrix(apply(IV[,-1, drop = FALSE], 2, FUN = mean))
descriptive_statistics <- list(Sample_Size, DV_mean, IV_means)
names(descriptive_statistics) <- c("Sample Size", "Mean of the Dependent Variable", "Mean(s) of the Independent Variable(s)")
## Regression coefficients, predicted values and residuals using matrix algebra:
model_coefficients  <- (solve(t(IV) %*% IV)) %*% (t(IV) %*% DV)
predicted_values <- IV %*% model_coefficients
error_residuals <- DV - predicted_values
## Simple plot of predicted values against the residuals:
simple_plot <- plot(predicted_values, error_residuals)
list_of_information <- list(descriptive_statistics, model_coefficients, simple_plot)
names(list_of_information) <- c("Descriptive statistics", "Regression coefficients",
"Simple plot of predicted values against the residuals")
## Finally, the function should return the created list that holds all information
return(list_of_information)
}
Regression_Function(data = gala_data2)
Regression_Function <- function(dataset, DV = dataset[, 1], IV = dataset[, 2:ncol(dataset)]) { ## question: how to allow IV to be any number of things
DV <- matrix(DV, nrow = nrow(dataset))
IV <- cbind(rep(1,nrow(dataset)), matrix(IV, nrow = nrow(dataset)))
IV <- as.matrix(IV)
## Descriptive statistics of data:
Sample_Size <- nrow(dataset)
DV_mean <- mean(DV)
IV_means <- as.matrix(apply(IV[,-1, drop = FALSE], 2, FUN = mean))
descriptive_statistics <- list(Sample_Size, DV_mean, IV_means)
names(descriptive_statistics) <- c("Sample Size", "Mean of the Dependent Variable", "Mean(s) of the Independent Variable(s)")
## Regression coefficients, predicted values and residuals using matrix algebra:
model_coefficients  <- (solve(t(IV) %*% IV)) %*% (t(IV) %*% DV)
predicted_values <- IV %*% model_coefficients
error_residuals <- DV - predicted_values
## Simple plot of predicted values against the residuals:
simple_plot <- plot(predicted_values, error_residuals)
list_of_information <- list(descriptive_statistics, model_coefficients, simple_plot)
names(list_of_information) <- c("Descriptive statistics", "Regression coefficients",
"Simple plot of predicted values against the residuals")
## Finally, the function should return the created list that holds all information
return(list_of_information)
}
Regression_Function(data = gala_data2)
## Running the function on the tortoise dataset, the coefficients match
Regression_Function(data = gala_data, DV = gala_data$Species, IV = c(gala_data$Area, gala_data$Elevation, gala_data$Endemics))
Regression_Function(data = gala_data2)
Regression_Function <- function(dataset, DV = dataset[, 1], IV = dataset[, -1]) { ## question: how to allow IV to be any number of things
DV <- matrix(DV, nrow = nrow(dataset))
IV <- cbind(rep(1,nrow(dataset)), matrix(IV, nrow = nrow(dataset)))
IV <- as.matrix(IV)
## Descriptive statistics of data:
Sample_Size <- nrow(dataset)
DV_mean <- mean(DV)
IV_means <- as.matrix(apply(IV[,-1, drop = FALSE], 2, FUN = mean))
descriptive_statistics <- list(Sample_Size, DV_mean, IV_means)
names(descriptive_statistics) <- c("Sample Size", "Mean of the Dependent Variable", "Mean(s) of the Independent Variable(s)")
## Regression coefficients, predicted values and residuals using matrix algebra:
model_coefficients  <- (solve(t(IV) %*% IV)) %*% (t(IV) %*% DV)
predicted_values <- IV %*% model_coefficients
error_residuals <- DV - predicted_values
## Simple plot of predicted values against the residuals:
simple_plot <- plot(predicted_values, error_residuals)
list_of_information <- list(descriptive_statistics, model_coefficients, simple_plot)
names(list_of_information) <- c("Descriptive statistics", "Regression coefficients",
"Simple plot of predicted values against the residuals")
## Finally, the function should return the created list that holds all information
return(list_of_information)
}
## Running the function on the tortoise dataset, the coefficients match
Regression_Function(data = gala_data, DV = gala_data$Species, IV = c(gala_data$Area, gala_data$Elevation, gala_data$Endemics))
Regression_Function(data = gala_data2)
Regression_Function <- function(dataset, DV = dataset[, 1], IV = dataset[, -1]) { ## question: how to allow IV to be any number of things
DV <- matrix(DV, nrow = nrow(dataset))
IV <- cbind(rep(1,nrow(dataset)), matrix(IV, nrow = nrow(dataset)))
IV <- as.matrix(IV)
## Descriptive statistics of data:
Sample_Size <- nrow(dataset)
DV_mean <- mean(DV)
IV_means <- as.matrix(apply(IV[,-1], 2, FUN = mean))
descriptive_statistics <- list(Sample_Size, DV_mean, IV_means)
names(descriptive_statistics) <- c("Sample Size", "Mean of the Dependent Variable", "Mean(s) of the Independent Variable(s)")
## Regression coefficients, predicted values and residuals using matrix algebra:
model_coefficients  <- (solve(t(IV) %*% IV)) %*% (t(IV) %*% DV)
predicted_values <- IV %*% model_coefficients
error_residuals <- DV - predicted_values
## Simple plot of predicted values against the residuals:
simple_plot <- plot(predicted_values, error_residuals)
list_of_information <- list(descriptive_statistics, model_coefficients, simple_plot)
names(list_of_information) <- c("Descriptive statistics", "Regression coefficients",
"Simple plot of predicted values against the residuals")
## Finally, the function should return the created list that holds all information
return(list_of_information)
}
## Running the function on the tortoise dataset, the coefficients match
Regression_Function(data = gala_data, DV = gala_data$Species, IV = c(gala_data$Area, gala_data$Elevation, gala_data$Endemics))
Regression_Function(data = gala_data2)
## Running the function on the tortoise dataset, the coefficients match
Regression_Function(data = gala_data, DV = gala_data$Species, IV = c(gala_data$Area, gala_data$Elevation, gala_data$Endemics))
Regression_Function(data = gala_data2)
Regression_Function <- function(dataset, DV = dataset[, 1], IV = dataset[, -1]) { ## question: how to allow IV to be any number of things
DV <- matrix(DV, nrow = nrow(dataset))
IV <- cbind(rep(1,nrow(dataset)), matrix(IV, nrow = nrow(dataset)))
## Descriptive statistics of data:
Sample_Size <- nrow(dataset)
DV_mean <- mean(DV)
IV_means <- as.matrix(apply(IV[, -1], 2, FUN = mean))
descriptive_statistics <- list(Sample_Size, DV_mean, IV_means)
names(descriptive_statistics) <- c("Sample Size", "Mean of the Dependent Variable", "Mean(s) of the Independent Variable(s)")
## Regression coefficients, predicted values and residuals using matrix algebra:
model_coefficients  <- (solve(t(IV) %*% IV)) %*% (t(IV) %*% DV)
predicted_values <- IV %*% model_coefficients
error_residuals <- DV - predicted_values
## Simple plot of predicted values against the residuals:
simple_plot <- plot(predicted_values, error_residuals)
list_of_information <- list(descriptive_statistics, model_coefficients, simple_plot)
names(list_of_information) <- c("Descriptive statistics", "Regression coefficients",
"Simple plot of predicted values against the residuals")
## Finally, the function should return the created list that holds all information
return(list_of_information)
}
## Running the function on the tortoise dataset, the coefficients match
Regression_Function(data = gala_data, DV = gala_data$Species, IV = c(gala_data$Area, gala_data$Elevation, gala_data$Endemics))
Regression_Function(data = gala_data2)
Regression_Function(data = gala_data2)
Regression_Function(data = gala_data2)
rm(list=ls())
## For a t-test, someone should have two vectors as input, so the function should also ask for two vectors
myTtest <- function(x, y) {
## First, ask and define a few values (such as length) necessary to calculate the t-test
n_x <- length(x)
n_y <- length(y)
## now, we  calculate the pooled sd through the following formula, using the built-in function var()
pooled_s <- sqrt(((n_x - 1)*(var(x)) + (n_y - 1)*(var(y)))/(n_x + n_y - 2))
## knowing the pooled_s, we can calculate the t-statistic through the final formula using the built-in function mean()
t_test <- (mean(x) - mean(y))/(pooled_s * sqrt((1/n_x)+(1/n_y)))
## Question 3:
## To get the p-value, we use the built-in function pt(), in this function, we need to define the t-statistic (gained above) and the degrees of freedom
## Furthermore, to get the correct p-value, we should make an if-statement, because:
if(t_test < 0) {
## if the t-value is below 0, it means we need to gain the p-value for the lower tail
p_value <- 2 * pt(t_test, df = n_x + n_y - 2, lower.tail = TRUE)
} else {
## if the t-value is above 0, it means we need to gain the p-value for the upper tail
p_value <- 2 * pt(t_test, df = n_x + n_y - 2, lower.tail = FALSE)
## Finally, in both cases the p-value should be multiplied by 2, because we are doing a two-tailed test
}
## Question 4:
## Create a list of values that we wish to have as output
list_of_values <- list(t_test, n_x + n_y - 2, p_value, c(mean(x), mean(y)))
names(list_of_values) <- c("t-statistic", "degrees of freedom", "p-value", "Group means of x and y respectively")
## return the list of values
return(list_of_values)
}
## To test whether the results match, create the two datasets and run it with both t-tests
CSFI <- c(2,5,5,6,6,7,8,9)
TFI <- c(1,1,2,3,3,4,5,7,7,8)
t.test(CSFI, TFI, var.equal = TRUE)
myTtest(CSFI, TFI)
t.test(TFI, CSFI, var.equal = TRUE)
myTtest(TFI, CSFI)
## Perform the multiple regression through the lm() function specifying the correct variables through the formula
regression_model <- lm(Species ~ Area + Elevation + Endemics, data = gala_data)
## Gain the correct statistics/estimates using the summary() function
summary(regression_model)
## Create a simple scatterplot of the predicted (also known as fitted) values against the residuals
plot(regression_model$fitted.values, regression_model$residuals)
Regression_Function(gala_data)
Regression_Function(data = gala_data)
## Running the function on the tortoise dataset with the correct specifications, the coefficients match
Regression_Function(data = gala_data, DV = gala_data[, 1], IV = gala_data[, 2:4])
Regression_Function <- function(dataset, DV = dataset[, 1], IV = dataset[, 2:ncol(dataset)]) {
## First, we should specify that both the DV and IVs are matrices, otherwise we won't be able to do matrix multiplication
DV <- as.matrix(DV)
## For the IV, it is important to also add a column that exists of only 1's so we can get the correct intercept
IV <- cbind(rep(1,nrow(dataset)), as.matrix(IV))
## Descriptive statistics of data: we want the sample size and means of all variables in the model
Sample_Size <- nrow(dataset)
DV_mean <- mean(DV)
IV_means <- as.matrix(colMeans(IV[, -1, drop = FALSE]))
IV_sds <- as.matrix(apply(IV[, -1], 2, FUN = sd))
IV_info <- cbind(IV_means, IV_sds)
## Put all the descriptive statistics in a list and give them aptly names
descriptive_statistics <- list(Sample_Size, DV_mean, IV_info)
names(descriptive_statistics) <- c("Sample Size", "Mean of the Dependent Variable",
"Mean(s) and Standard Deviation(s) - respectively - of the Independent Variable(s)")
## Regression coefficients, predicted values and residuals using matrix algebra:
## Copy the above used code for matrix multiplication to gain the correct values
model_coefficients  <- (solve(t(IV) %*% IV)) %*% (t(IV) %*% DV)
predicted_values <- IV %*% model_coefficients
error_residuals <- DV - predicted_values
## Simple plot of predicted values against the residuals: simply use the plot() function with our newly calculated
## predicted_values and error_residuals
simple_plot <- plot(predicted_values, error_residuals)
## Now before we return all this info, we put in a list all the information we want to give when the function is called
## This includes the list of descriptive statistics, the model coefficients and the simple plot
list_of_information <- list(descriptive_statistics, model_coefficients, simple_plot)
## Furthermore, we give the different parts of the list apt names
names(list_of_information) <- c("Descriptive statistics", "Regression coefficients",
"Simple plot of predicted values against the residuals")
## Finally, the function should return the created list that holds all information
return(list_of_information)
}
Regression_Function(data = gala_data)
## Running the function on the tortoise dataset with the correct specifications, the coefficients match
Regression_Function(data = gala_data, DV = gala_data[, 1], IV = gala_data[, 2:4])
## First, create matrices out of the IVs and DVs with the correct number of columns and rows
DVEx <- matrix(gala_data$Species, ncol = 1, nrow = 30)
## For the IVs, we also add a column that consits of only 1's in order to gain the intercept
IVEx <- matrix(c(gala_data$Area, gala_data$Elevation, gala_data$Endemics, rep(1,30)), ncol = 4, nrow = 30)
## Now, correctly multiply the matrices, using the t() function to gain the transpose of matrices
## and using solve() to gain the inverse of a matrix
b_coefficients <- (solve(t(IVEx) %*% IVEx)) %*% (t(IVEx) %*% DVEx)
b_coefficients
## To get the predicted values, we matrix multiply the IVs with the b_coefficients
predicted_y <- IVEx %*% b_coefficients
predicted_y
## To get the error residuals, we subtract from the true score (the DV), the predicted_y
err_residuals <- DVEx - predicted_y
err_residuals
rm(list=ls())
## For a t-test, someone should have two vectors as input, so the function should also ask for two vectors
myTtest <- function(x, y) {
## First, ask and define a few values (such as length) necessary to calculate the t-test
n_x <- length(x)
n_y <- length(y)
## now, we  calculate the pooled sd through the following formula, using the built-in function var()
pooled_s <- sqrt(((n_x - 1)*(var(x)) + (n_y - 1)*(var(y)))/(n_x + n_y - 2))
## knowing the pooled_s, we can calculate the t-statistic through the final formula using the built-in function mean()
t_test <- (mean(x) - mean(y))/(pooled_s * sqrt((1/n_x)+(1/n_y)))
## Question 3:
## To get the p-value, we use the built-in function pt(), in this function, we need to
## define the t-statistic (gained above) and the degrees of freedom
## Furthermore, to get the correct p-value, we should make an if-statement, because:
if(t_test < 0) {
## if the t-value is below 0, it means we need to gain the p-value for the lower tail
p_value <- 2 * pt(t_test, df = n_x + n_y - 2, lower.tail = TRUE)
} else {
## if the t-value is above 0, it means we need to gain the p-value for the upper tail
p_value <- 2 * pt(t_test, df = n_x + n_y - 2, lower.tail = FALSE)
## Finally, in both cases the p-value should be multiplied by 2, because we are doing a two-tailed test
}
## Question 4:
## Create a list of values that we wish to have as output and name the lists
list_of_values <- list(t_test, n_x + n_y - 2, p_value, c(mean(x), mean(y)))
names(list_of_values) <- c("t-statistic", "degrees of freedom", "p-value", "Group means of x and y respectively")
## return the list of values
return(list_of_values)
}
## To test whether the results match, create the two datasets and run it with both t-tests
CSFI <- c(2,5,5,6,6,7,8,9)
TFI <- c(1,1,2,3,3,4,5,7,7,8)
t.test(CSFI, TFI, var.equal = TRUE)
myTtest(CSFI, TFI)
t.test(TFI, CSFI, var.equal = TRUE)
myTtest(TFI, CSFI)
## First load the correct file with the right separator specified
gala_data <- read.csv(file = "gala.txt", sep = " ")
## Perform the multiple regression through the lm() function specifying the correct variables through the formula
regression_model <- lm(Species ~ Area + Elevation + Endemics, data = gala_data)
## Gain the correct statistics/estimates using the summary() function
summary(regression_model)
## Create a simple scatterplot of the predicted (also known as fitted) values against the residuals
plot(regression_model$fitted.values, regression_model$residuals)
## First, create matrices out of the IVs and DVs with the correct number of columns and rows
DVEx <- matrix(gala_data$Species, ncol = 1, nrow = 30)
## For the IVs, we also add a column that consits of only 1's in order to gain the intercept
IVEx <- matrix(c(gala_data$Area, gala_data$Elevation, gala_data$Endemics, rep(1,30)), ncol = 4, nrow = 30)
## Now, correctly multiply the matrices, using the t() function to gain the transpose of matrices
## and using solve() to gain the inverse of a matrix
b_coefficients <- (solve(t(IVEx) %*% IVEx)) %*% (t(IVEx) %*% DVEx)
b_coefficients
## To get the predicted values, we matrix multiply the IVs with the b_coefficients
predicted_y <- IVEx %*% b_coefficients
predicted_y
## To get the error residuals, we subtract from the true score (the DV), the predicted_y
err_residuals <- DVEx - predicted_y
err_residuals
Regression_Function <- function(dataset, DV = dataset[, 1], IV = dataset[, 2:ncol(dataset)]) {
## First, we should change both the DV and IVs into matrices, otherwise we won't be able to do matrix multiplication
DV <- as.matrix(DV)
## For the IV, it is important to also add a column that exists of only 1's so we can get the correct intercept
IV <- cbind(rep(1,nrow(dataset)), as.matrix(IV))
## Descriptive statistics of data:
## We want the sample size, which is equal to the number of rows of the dataset
Sample_Size <- nrow(dataset)
## We want the means of the DV and all IVs
DV_mean <- mean(DV)
## For the IVs, we make use of the colMeans() function
IV_means <- as.matrix(colMeans(IV[, -1, drop = FALSE]))
## We want the standard deviations of all IVs
## We gain these through using the apply function, applying the sd() function to all columns in the IV matrix
IV_sds <- as.matrix(apply(IV[, -1], 2, FUN = sd))
## Finally, we column bind the means and standard deviations
IV_info <- cbind(IV_means, IV_sds)
## Put all the descriptive statistics in a list and give them aptly names
descriptive_statistics <- list(Sample_Size, DV_mean, IV_info)
names(descriptive_statistics) <- c("Sample Size", "Mean of the Dependent Variable",
"Mean(s) and Standard Deviation(s) - respectively - of the Independent Variable(s)")
## Regression coefficients, predicted values and residuals using matrix algebra:
## Copy the above used code (with changed variable-names) for matrix multiplication to gain the correct values
model_coefficients  <- (solve(t(IV) %*% IV)) %*% (t(IV) %*% DV)
predicted_values <- IV %*% model_coefficients
error_residuals <- DV - predicted_values
## Simple plot of predicted values against the residuals: simply use the plot() function with our newly calculated
## predicted_values and error_residuals
simple_plot <- plot(predicted_values, error_residuals)
## Now before we return all this info, we put in a list all the information we want to give when the function is called
## This includes the list of descriptive statistics, the model coefficients and the simple plot
list_of_information <- list(descriptive_statistics, model_coefficients, simple_plot)
## Furthermore, we give the different parts of the list apt names
names(list_of_information) <- c("Descriptive statistics", "Regression coefficients",
"Simple plot of predicted values against the residuals")
## Finally, the function should return the created list that holds all information
return(list_of_information)
}
## Running the function on the tortoise dataset with the correct specifications, the coefficients match
Regression_Function(data = gala_data, DV = gala_data[, 1], IV = gala_data[, 2:4])
Regression_Function(data = gala_data[1:4])
## The function can be specified in two ways for this dataset:
Regression_Function(data = gala_data, DV = gala_data[, 1], IV = gala_data[, 2:4])
Regression_Function(data = gala_data[1:4])
?hist
set.seed(9)
V1 <- c(10, 11, 11, 10, 12)
V2 <- c(12, 10, 14, 13, 12)
rm(list=ls())
set.seed(9)
V1 <- c(10, 11, 11, 10, 12)
V2 <- c(12, 10, 14, 13, 12)
bootstrapping_1000 <- function(X, Y) {
## Calculating the t-test on the sample data (using t.test)
initial_t_test <- t.test(X, Y)
## save only the t-statistic in a new value
initial_t_statistic <- initial_t_test$statistic
## create space for the 1000 t-statistic values we will gain from bootstrapping
t_statistic_values <- rep(0, 1000)
## for-loop sampling 1000 bootstrap samples by using sample() for both groups
## create the for loop
for(i in 1:1000) {
## In every loop, sample with replacement, 5 elements from both inputs and save this in a new value
S1 <- sample(x = X, replace = TRUE)
S2 <- sample(x = Y, replace = TRUE)
## calculating t-statistic for each bootstrap sample
## Then, in every loop, perform the t.test
sample_result <- t.test(S1, S2)
## Finally, for ever loop, the t-value should be saved as the ith value, from the ith loop in the appropriate space
t_statistic_values[i] <- sample_result$statistic
}
## compute bootstrap 95% confidence interval based on percentiles (use quantiles()) of the 1000 t-statistics
CI <- quantile(t_statistic_values, p = c(0.025, 0.975))
## plot histogram of the bootstrap sampling distribution of the t-statistic values
t_test_histogram <- hist(t_statistic_values, nclass = 50, main = "Bootstrap distribution of the t-statistic with 95% Confidence Interval")
abline(v = CI, col = "blue")
## Export appropriate results
## First make a list of all results to be shown
list_of_information <- list(initial_t_statistic, CI)
## Then name them aptly
names(list_of_information) <- c("Initial result of the t-test using the sample data", "95% Confidence Interval of the t-statistic")
## Finally, return the list of information
return(list_of_information)
}
bootstrapping_1000 <- function(X, Y) {
## Calculating the t-test on the sample data (using t.test)
initial_t_test <- t.test(X, Y)
## save only the t-statistic in a new value
initial_t_statistic <- initial_t_test$statistic
## create space for the 1000 t-statistic values we will gain from bootstrapping
t_statistic_values <- rep(0, 1000)
## for-loop sampling 1000 bootstrap samples by using sample() for both groups
## create the for loop
for(i in 1:1000) {
## In every loop, sample with replacement, 5 elements from both inputs and save this in a new value
S1 <- sample(x = X, replace = TRUE)
S2 <- sample(x = Y, replace = TRUE)
## calculating t-statistic for each bootstrap sample
## Then, in every loop, perform the t.test
sample_result <- t.test(S1, S2)
## Finally, for ever loop, the t-value should be saved as the ith value, from the ith loop in the appropriate space
t_statistic_values[i] <- sample_result$statistic
}
## compute bootstrap 95% confidence interval based on percentiles (use quantiles()) of the 1000 t-statistics
CI <- quantile(t_statistic_values, p = c(0.025, 0.975))
## plot histogram of the bootstrap sampling distribution of the t-statistic values
t_test_histogram <- hist(t_statistic_values, nclass = 50, main = "Bootstrap distribution of the t-statistic with 95% Confidence Interval")
abline(v = CI, col = "blue")
## Export appropriate results
## First make a list of all results to be shown
list_of_information <- list(initial_t_statistic, CI)
## Then name them aptly
names(list_of_information) <- c("Initial result of the t-test using the sample data", "95% Confidence Interval of the t-statistic")
## Finally, return the list of information
return(list_of_information)
}
## To try it out:
bootstrapping_1000(V1, V2)
rm(list = ls())
logregNewtonRaphson <- function(X, y, max.iter=30, tol=1E-6){
X <- cbind(1, X)
beta <- beta.last <- rep(0, ncol(X))
it <- 1
while (it <= max.iter){
p <- as.vector(1/(1 + exp(-X %*% beta)))
W <- diag(p * (1 - p))
var.beta <- solve(t(X) %*% W %*% X)
beta <- beta + var.beta %*% t(X) %*% (y - p)
if (max(abs(beta - beta.last)/(abs(beta.last)
+ 0.01*tol)) < tol)
break
beta.last <- beta
it <- it + 1
}
if (it > max.iter)
warning(maximum iterations exceeded)
list(coefficients=as.vector(beta), var=var.beta,
iterations=it)
}
logregNewtonRaphson <- function(X, y, max.iter=30, tol=1E-6){
X <- cbind(1, X)
beta <- beta.last <- rep(0, ncol(X))
it <- 1
while (it <= max.iter){
p <- as.vector(1/(1 + exp(-X %*% beta)))
W <- diag(p * (1 - p))
var.beta <- solve(t(X) %*% W %*% X)
beta <- beta + var.beta %*% t(X) %*% (y - p)
if (max(abs(beta - beta.last)/(abs(beta.last)
+ 0.01*tol)) < tol)
break
beta.last <- beta
it <- it + 1
}
if (it > max.iter)
warning("maximum iterations exceeded")
list(coefficients=as.vector(beta), var=var.beta,
iterations=it)
}
?max
