## Finally, in both cases the p-value should be multiplied by 2, because we are doing a two-tailed test
}
## Question 4:
## create a list of values that we wish to have as output
list_of_values <- list(t_test, p_value, c(mean(x), mean(y)))
names(list_of_values) <- c("t-statistic", "p-value", "group means")
## return the list of values
return(list_of_values)
}
myTtest(CSFI, TFI)
## For a t-test, someone should have two vectors as input, so the function should also ask for two vectors
myTtest <- function(x, y) {
## First, ask and define a few values necessary to calculate the t-test
n_x <- length(x)
n_y <- length(y)
## now, we  calculate the pooled sd through the following formula, using the built-in function var()
pooled_s <- sqrt(((n_x - 1)*(var(x)) + (n_y - 1)*(var(y)))/(n_x + n_y - 2))
## knowing the pooled_s, we can calculate the t-statistic through the final formula using the built-in function mean()
t_test <- (mean(x) - mean(y))/(pooled_s * sqrt((1/n_x)+(1/n_y)))
## Question 3:
## To get the p-value, we use the built-in function pt(), in this function, we need to define the t-statistic (gained above) and the degrees of freedom
## Furthermore, to get the correct p-value, we should make an if-statement, because:
if(t_test < 0) {
## if the t-value is below 0, it means we need to gain the p-value for the lower tail
p_value <- 2 * pt(t_test, df = n_x + n_y - 2, lower.tail = TRUE)
} else {
## if the t-value is above 0, it means we need to gain the p-value for the upper tail
p_value <- 2 * pt(t_test, df = n_x + n_y - 2, lower.tail = FALSE)
## Finally, in both cases the p-value should be multiplied by 2, because we are doing a two-tailed test
}
## Question 4:
## create a list of values that we wish to have as output
list_of_values <- list(t_test, p_value, c(mean(x), mean(y)))
names(list_of_values) <- c("t-statistic", "p-value", "Group means of x and y respectively")
## return the list of values
return(list_of_values)
}
myTtest(CSFI, TFI)
## For a t-test, someone should have two vectors as input, so the function should also ask for two vectors
myTtest <- function(x, y) {
## First, ask and define a few values necessary to calculate the t-test
n_x <- length(x)
n_y <- length(y)
## now, we  calculate the pooled sd through the following formula, using the built-in function var()
pooled_s <- sqrt(((n_x - 1)*(var(x)) + (n_y - 1)*(var(y)))/(n_x + n_y - 2))
## knowing the pooled_s, we can calculate the t-statistic through the final formula using the built-in function mean()
t_test <- (mean(x) - mean(y))/(pooled_s * sqrt((1/n_x)+(1/n_y)))
## Question 3:
## To get the p-value, we use the built-in function pt(), in this function, we need to define the t-statistic (gained above) and the degrees of freedom
## Furthermore, to get the correct p-value, we should make an if-statement, because:
if(t_test < 0) {
## if the t-value is below 0, it means we need to gain the p-value for the lower tail
p_value <- 2 * pt(t_test, df = n_x + n_y - 2, lower.tail = TRUE)
} else {
## if the t-value is above 0, it means we need to gain the p-value for the upper tail
p_value <- 2 * pt(t_test, df = n_x + n_y - 2, lower.tail = FALSE)
## Finally, in both cases the p-value should be multiplied by 2, because we are doing a two-tailed test
}
## Question 4:
## create a list of values that we wish to have as output
list_of_values <- list(t_test, n_x + n_y - 2, p_value, c(mean(x), mean(y)))
names(list_of_values) <- c("t-statistic", "degrees of freedom","p-value", "Group means of x and y respectively")
## return the list of values
return(list_of_values)
}
t.test(CSFI, TFI, var.equal = TRUE)
myTtest(CSFI, TFI)
?c
names(list_of_values) <- c("t-statistic", "degrees of freedom","p-value", c("Group means of", x, "and", y, "respectively"))
## For a t-test, someone should have two vectors as input, so the function should also ask for two vectors
myTtest <- function(x, y) {
## First, ask and define a few values necessary to calculate the t-test
n_x <- length(x)
n_y <- length(y)
## now, we  calculate the pooled sd through the following formula, using the built-in function var()
pooled_s <- sqrt(((n_x - 1)*(var(x)) + (n_y - 1)*(var(y)))/(n_x + n_y - 2))
## knowing the pooled_s, we can calculate the t-statistic through the final formula using the built-in function mean()
t_test <- (mean(x) - mean(y))/(pooled_s * sqrt((1/n_x)+(1/n_y)))
## Question 3:
## To get the p-value, we use the built-in function pt(), in this function, we need to define the t-statistic (gained above) and the degrees of freedom
## Furthermore, to get the correct p-value, we should make an if-statement, because:
if(t_test < 0) {
## if the t-value is below 0, it means we need to gain the p-value for the lower tail
p_value <- 2 * pt(t_test, df = n_x + n_y - 2, lower.tail = TRUE)
} else {
## if the t-value is above 0, it means we need to gain the p-value for the upper tail
p_value <- 2 * pt(t_test, df = n_x + n_y - 2, lower.tail = FALSE)
## Finally, in both cases the p-value should be multiplied by 2, because we are doing a two-tailed test
}
## Question 4:
## create a list of values that we wish to have as output
list_of_values <- list(t_test, n_x + n_y - 2, p_value, c(mean(x), mean(y)))
names(list_of_values) <- c("t-statistic", "degrees of freedom","p-value", c("Group means of", x, "and", y, "respectively"))
## return the list of values
return(list_of_values)
}
myTtest(CSFI, TFI)
?names
## For a t-test, someone should have two vectors as input, so the function should also ask for two vectors
myTtest <- function(x, y) {
## First, ask and define a few values necessary to calculate the t-test
n_x <- length(x)
n_y <- length(y)
## now, we  calculate the pooled sd through the following formula, using the built-in function var()
pooled_s <- sqrt(((n_x - 1)*(var(x)) + (n_y - 1)*(var(y)))/(n_x + n_y - 2))
## knowing the pooled_s, we can calculate the t-statistic through the final formula using the built-in function mean()
t_test <- (mean(x) - mean(y))/(pooled_s * sqrt((1/n_x)+(1/n_y)))
## Question 3:
## To get the p-value, we use the built-in function pt(), in this function, we need to define the t-statistic (gained above) and the degrees of freedom
## Furthermore, to get the correct p-value, we should make an if-statement, because:
if(t_test < 0) {
## if the t-value is below 0, it means we need to gain the p-value for the lower tail
p_value <- 2 * pt(t_test, df = n_x + n_y - 2, lower.tail = TRUE)
} else {
## if the t-value is above 0, it means we need to gain the p-value for the upper tail
p_value <- 2 * pt(t_test, df = n_x + n_y - 2, lower.tail = FALSE)
## Finally, in both cases the p-value should be multiplied by 2, because we are doing a two-tailed test
}
## Question 4:
## create a list of values that we wish to have as output
list_of_values <- list(t_test, n_x + n_y - 2, p_value, c(mean(x), mean(y)))
names(list_of_values) <- c("t-statistic", "degrees of freedom","p-value", "Group means of x and y respectively")
## return the list of values
return(list_of_values)
}
t.test(CSFI, TFI, var.equal = TRUE)
myTtest(CSFI, TFI)
?sprintf
names(list_of_values) <- c("t-statistic", "degrees of freedom", "p-value", sprintf("Group means of %s and %s respectively", x, y))
## For a t-test, someone should have two vectors as input, so the function should also ask for two vectors
myTtest <- function(x, y) {
## First, ask and define a few values necessary to calculate the t-test
n_x <- length(x)
n_y <- length(y)
## now, we  calculate the pooled sd through the following formula, using the built-in function var()
pooled_s <- sqrt(((n_x - 1)*(var(x)) + (n_y - 1)*(var(y)))/(n_x + n_y - 2))
## knowing the pooled_s, we can calculate the t-statistic through the final formula using the built-in function mean()
t_test <- (mean(x) - mean(y))/(pooled_s * sqrt((1/n_x)+(1/n_y)))
## Question 3:
## To get the p-value, we use the built-in function pt(), in this function, we need to define the t-statistic (gained above) and the degrees of freedom
## Furthermore, to get the correct p-value, we should make an if-statement, because:
if(t_test < 0) {
## if the t-value is below 0, it means we need to gain the p-value for the lower tail
p_value <- 2 * pt(t_test, df = n_x + n_y - 2, lower.tail = TRUE)
} else {
## if the t-value is above 0, it means we need to gain the p-value for the upper tail
p_value <- 2 * pt(t_test, df = n_x + n_y - 2, lower.tail = FALSE)
## Finally, in both cases the p-value should be multiplied by 2, because we are doing a two-tailed test
}
## Question 4:
## create a list of values that we wish to have as output
list_of_values <- list(t_test, n_x + n_y - 2, p_value, c(mean(x), mean(y)))
names(list_of_values) <- c("t-statistic", "degrees of freedom", "p-value", sprintf("Group means of %s and %s respectively", x, y))
## return the list of values
return(list_of_values)
}
myTtest(CSFI, TFI)
names(list_of_values) <- c("t-statistic", "degrees of freedom", "p-value", sprintf("Group means of %s and %r respectively", x, y))
## For a t-test, someone should have two vectors as input, so the function should also ask for two vectors
myTtest <- function(x, y) {
## First, ask and define a few values necessary to calculate the t-test
n_x <- length(x)
n_y <- length(y)
## now, we  calculate the pooled sd through the following formula, using the built-in function var()
pooled_s <- sqrt(((n_x - 1)*(var(x)) + (n_y - 1)*(var(y)))/(n_x + n_y - 2))
## knowing the pooled_s, we can calculate the t-statistic through the final formula using the built-in function mean()
t_test <- (mean(x) - mean(y))/(pooled_s * sqrt((1/n_x)+(1/n_y)))
## Question 3:
## To get the p-value, we use the built-in function pt(), in this function, we need to define the t-statistic (gained above) and the degrees of freedom
## Furthermore, to get the correct p-value, we should make an if-statement, because:
if(t_test < 0) {
## if the t-value is below 0, it means we need to gain the p-value for the lower tail
p_value <- 2 * pt(t_test, df = n_x + n_y - 2, lower.tail = TRUE)
} else {
## if the t-value is above 0, it means we need to gain the p-value for the upper tail
p_value <- 2 * pt(t_test, df = n_x + n_y - 2, lower.tail = FALSE)
## Finally, in both cases the p-value should be multiplied by 2, because we are doing a two-tailed test
}
## Question 4:
## create a list of values that we wish to have as output
list_of_values <- list(t_test, n_x + n_y - 2, p_value, c(mean(x), mean(y)))
names(list_of_values) <- c("t-statistic", "degrees of freedom", "p-value", sprintf("Group means of %s and %r respectively", x, y))
## return the list of values
return(list_of_values)
}
myTtest(CSFI, TFI)
## For a t-test, someone should have two vectors as input, so the function should also ask for two vectors
myTtest <- function(x, y) {
## First, ask and define a few values necessary to calculate the t-test
n_x <- length(x)
n_y <- length(y)
## now, we  calculate the pooled sd through the following formula, using the built-in function var()
pooled_s <- sqrt(((n_x - 1)*(var(x)) + (n_y - 1)*(var(y)))/(n_x + n_y - 2))
## knowing the pooled_s, we can calculate the t-statistic through the final formula using the built-in function mean()
t_test <- (mean(x) - mean(y))/(pooled_s * sqrt((1/n_x)+(1/n_y)))
## Question 3:
## To get the p-value, we use the built-in function pt(), in this function, we need to define the t-statistic (gained above) and the degrees of freedom
## Furthermore, to get the correct p-value, we should make an if-statement, because:
if(t_test < 0) {
## if the t-value is below 0, it means we need to gain the p-value for the lower tail
p_value <- 2 * pt(t_test, df = n_x + n_y - 2, lower.tail = TRUE)
} else {
## if the t-value is above 0, it means we need to gain the p-value for the upper tail
p_value <- 2 * pt(t_test, df = n_x + n_y - 2, lower.tail = FALSE)
## Finally, in both cases the p-value should be multiplied by 2, because we are doing a two-tailed test
}
## Question 4:
## create a list of values that we wish to have as output
list_of_values <- list(t_test, n_x + n_y - 2, p_value, c(mean(x), mean(y)))
names(list_of_values) <- c("t-statistic", "degrees of freedom", "p-value", sprintf("Group means of %s and y respectively", x))
## return the list of values
return(list_of_values)
}
## To test whether the results match, create the two factors and run it with both t-tests
CSFI <- c(2,5,5,6,6,7,8,9)
TFI <- c(1,1,2,3,3,4,5,7,7,8)
t.test(CSFI, TFI, var.equal = TRUE)
myTtest(CSFI, TFI)
names(list_of_values) <- c("t-statistic", "degrees of freedom", "p-value", sprintf("Group means of %s and y respectively", x))
## For a t-test, someone should have two vectors as input, so the function should also ask for two vectors
myTtest <- function(x, y) {
## First, ask and define a few values necessary to calculate the t-test
n_x <- length(x)
n_y <- length(y)
## now, we  calculate the pooled sd through the following formula, using the built-in function var()
pooled_s <- sqrt(((n_x - 1)*(var(x)) + (n_y - 1)*(var(y)))/(n_x + n_y - 2))
## knowing the pooled_s, we can calculate the t-statistic through the final formula using the built-in function mean()
t_test <- (mean(x) - mean(y))/(pooled_s * sqrt((1/n_x)+(1/n_y)))
## Question 3:
## To get the p-value, we use the built-in function pt(), in this function, we need to define the t-statistic (gained above) and the degrees of freedom
## Furthermore, to get the correct p-value, we should make an if-statement, because:
if(t_test < 0) {
## if the t-value is below 0, it means we need to gain the p-value for the lower tail
p_value <- 2 * pt(t_test, df = n_x + n_y - 2, lower.tail = TRUE)
} else {
## if the t-value is above 0, it means we need to gain the p-value for the upper tail
p_value <- 2 * pt(t_test, df = n_x + n_y - 2, lower.tail = FALSE)
## Finally, in both cases the p-value should be multiplied by 2, because we are doing a two-tailed test
}
## Question 4:
## create a list of values that we wish to have as output
list_of_values <- list(t_test, n_x + n_y - 2, p_value, c(mean(x), mean(y)))
names(list_of_values) <- c("t-statistic", "degrees of freedom", "p-value", sprintf("Group means of %s and y respectively", x))
## return the list of values
return(list_of_values)
}
## To test whether the results match, create the two factors and run it with both t-tests
CSFI <- c(2,5,5,6,6,7,8,9)
TFI <- c(1,1,2,3,3,4,5,7,7,8)
t.test(CSFI, TFI, var.equal = TRUE)
myTtest(CSFI, TFI)
## For a t-test, someone should have two vectors as input, so the function should also ask for two vectors
myTtest <- function(x, y) {
## First, ask and define a few values necessary to calculate the t-test
n_x <- length(x)
n_y <- length(y)
## now, we  calculate the pooled sd through the following formula, using the built-in function var()
pooled_s <- sqrt(((n_x - 1)*(var(x)) + (n_y - 1)*(var(y)))/(n_x + n_y - 2))
## knowing the pooled_s, we can calculate the t-statistic through the final formula using the built-in function mean()
t_test <- (mean(x) - mean(y))/(pooled_s * sqrt((1/n_x)+(1/n_y)))
## Question 3:
## To get the p-value, we use the built-in function pt(), in this function, we need to define the t-statistic (gained above) and the degrees of freedom
## Furthermore, to get the correct p-value, we should make an if-statement, because:
if(t_test < 0) {
## if the t-value is below 0, it means we need to gain the p-value for the lower tail
p_value <- 2 * pt(t_test, df = n_x + n_y - 2, lower.tail = TRUE)
} else {
## if the t-value is above 0, it means we need to gain the p-value for the upper tail
p_value <- 2 * pt(t_test, df = n_x + n_y - 2, lower.tail = FALSE)
## Finally, in both cases the p-value should be multiplied by 2, because we are doing a two-tailed test
}
## Question 4:
## create a list of values that we wish to have as output
list_of_values <- list(t_test, n_x + n_y - 2, p_value, c(mean(x), mean(y)))
names(list_of_values) <- c("t-statistic", "degrees of freedom", "p-value", "Group means of x and y respectively")
## return the list of values
return(list_of_values)
}
## To test whether the results match, create the two factors and run it with both t-tests
CSFI <- c(2,5,5,6,6,7,8,9)
TFI <- c(1,1,2,3,3,4,5,7,7,8)
t.test(CSFI, TFI, var.equal = TRUE)
myTtest(CSFI, TFI)
t.test(TFI, CSFI, var.equal = TRUE)
myTtest(TFI, CSFI)
## First load the correct file with the right separator specified
gala_data <- read.csv(file = "gala.txt", sep = " ")
## Perform the multiple regression through the lm() function specifying the correct variables through the formula
## Important to note is that we want to remove the intercept (by using + 0), because otherwise we won't be able to compare the coefficients
regression_model <- lm(Species ~ Area + Elevation + Endemics + 0, data = gala_data)
## Gain the correct statistics/estimates using the summary() function
summary(regression_model)
## Create a simple scatterplot of the predicted (also known as fitted) values against the residuals
plot(regression_model$fitted.values, regression_model$residuals)
## The regression coefficients:
DV <- matrix(gala_data$Species, ncol = 1, nrow = 30)
IVs <- matrix(c(gala_data$Area, gala_data$Elevation, gala_data$Endemics), ncol = 3, nrow = 30)
b_coefficients <- (solve(t(IVs) %*% IVs)) %*% (t(IVs) %*% DV)
b_coefficients
## The predicted values:
predicted_values <- IVs %*% b_coefficients
predicted_values
## The residuals:
error_residuals <- DV - predicted_values
error_residuals
Ex <- gala_data[,1]
Ex
View(gala_data)
gala_data[,!Ex]
gala_data[!Ex]
Ex2 <- gala_data[!Ex]
View(Ex2)
Ex2 <- gala_data[, !Ex]
Ex2 <- gala_data[, -Ex]
View(Ex2)
Ex2 <- gala_data[-Ex]
Ex <- gala_data[,1]
Ex
Ex2 <- gala_data[-Ex]
View(Ex2)
Ex <- matrix(gala_data[, 1])
Ex
Ex2 <- gala_data[-Ex]
Ex <- matrix(gala_data[, 1])
Ex
Ex2 <- matrix(gala_data[-Ex])
View(Ex2)
ncol()
?ncol
?matrix
Ex2 <- matrix(gala_data[-Ex], ncol = ncol(gala_data) - 1)
Ex <- matrix(gala_data[, 1])
Ex
Ex2 <- matrix(gala_data[-Ex], ncol = ncol(gala_data) - 1)
nrow(gala_data)
View(Ex2)
Ex2 <- matrix(gala_data[-Ex], nrow = nrow(gala_data), ncol = ncol(gala_data) - 1)
Ex <- matrix(gala_data[, 1])
Ex
Ex2 <- matrix(gala_data[-Ex], nrow = nrow(gala_data), ncol = ncol(gala_data) - 1)
View(Ex2)
Ex2 <- matrix(gala_data[, !Ex], nrow = nrow(gala_data), ncol = ncol(gala_data) - 1)
View(Ex2)
Ex2 <- matrix(gala_data[, -Ex], nrow = nrow(gala_data), ncol = ncol(gala_data) - 1)
View(Ex2)
Ex2 <- matrix(gala_data[, -Ex])
View(Ex2)
Ex <- matrix(gala_data[, 1])
Ex
Ex2 <- matrix(gala_data[, -Ex])
rm(Ex, Ex2)
gala_data[, 1]
gala_data[, !1]
Wha <- gala_data[, !1]
View(Wha)
Wha <- gala_data[, 2:ncol(gala_data)]
View(Wha)
rm(Wha)
rm(IVs, DV)
## The regression coefficients:
DVEx <- matrix(gala_data$Species, ncol = 1, nrow = 30)
IVEx <- matrix(c(gala_data$Area, gala_data$Elevation, gala_data$Endemics), ncol = 3, nrow = 30)
b_coefficients <- (solve(t(IVs) %*% IVs)) %*% (t(IVs) %*% DV)
b_coefficients
b_coefficients <- (solve(t(IVEx) %*% IVEx)) %*% (t(IVEx) %*% DVEx)
b_coefficients
## The predicted values:
predicted_values <- IVEx %*% b_coefficients
predicted_values
## The residuals:
error_residuals <- DVEx - predicted_values
error_residuals
b_coefficients <- (solve(t(IVEx) %*% IVEx)) %*% (t(IVEx) %*% DVEx)
b_coefficients
## The predicted values:
predicted_y <- IVEx %*% b_coefficients
predicted_y
## The residuals:
err_residuals <- DVEx - predicted_values
err_residuals
rm(list=ls())
Regression_Function <- function(data, DV = matrix(data[, 1]), IV = data[, 2:ncol(data)]) { ## question: how to allow IV to be any number of things
## Descriptive statistics of data:
descriptive_statistics <- ...
## Regression coefficients, predicted values and residuals using matrix algebra:
model_coefficients  <- (solve(t(IV) %*% IV)) %*% (t(IV) %*% DV)
predicted_values <- IV %*% model_coefficients
error_residuals <- DV - predicted_values
## Simple plot of predicted values against the residuals:
simple_plot <- plot(predicted_values, error_residuals)
list_of_information <- list(descriptive_statistics, model_coefficients, predicted_values, error_residuals, simple_plot)
names(list_of_information) <- c("Descriptive statistics", "Regression coefficients", "Predicted values", "Error/Residuals",
"Simple plot of predicted values against the residuals")
## Finally, the function should return the created list that holds all information
return(list_of_information)
}
## First load the correct file with the right separator specified
gala_data <- read.csv(file = "gala.txt", sep = " ")
Regression_Function(gala_data)
Regression_Function(data = gala_data)
Regression_Function <- function(data, DV = matrix(data[, 1]), IV = data[, 2:ncol(data)]) { ## question: how to allow IV to be any number of things
## Descriptive statistics of data:
descriptive_statistics <- "nothing for now"
## Regression coefficients, predicted values and residuals using matrix algebra:
model_coefficients  <- (solve(t(IV) %*% IV)) %*% (t(IV) %*% DV)
predicted_values <- IV %*% model_coefficients
error_residuals <- DV - predicted_values
## Simple plot of predicted values against the residuals:
simple_plot <- plot(predicted_values, error_residuals)
list_of_information <- list(descriptive_statistics, model_coefficients, predicted_values, error_residuals, simple_plot)
names(list_of_information) <- c("Descriptive statistics", "Regression coefficients", "Predicted values", "Error/Residuals",
"Simple plot of predicted values against the residuals")
## Finally, the function should return the created list that holds all information
return(list_of_information)
}
Regression_Function(data = gala_data)
?as.matrix
?as.matrix
Regression_Function <- function(data, DV = matrix(data[, 1]), IV = data[, 2:ncol(data)]) { ## question: how to allow IV to be any number of things
## Descriptive statistics of data:
descriptive_statistics <- "nothing for now"
## Regression coefficients, predicted values and residuals using matrix algebra:
DV <- as.matrix(DV)
IV <- as.matrix(IV)
model_coefficients  <- (solve(t(IV) %*% IV)) %*% (t(IV) %*% DV)
predicted_values <- IV %*% model_coefficients
error_residuals <- DV - predicted_values
## Simple plot of predicted values against the residuals:
simple_plot <- plot(predicted_values, error_residuals)
list_of_information <- list(descriptive_statistics, model_coefficients, predicted_values, error_residuals, simple_plot)
names(list_of_information) <- c("Descriptive statistics", "Regression coefficients", "Predicted values", "Error/Residuals",
"Simple plot of predicted values against the residuals")
## Finally, the function should return the created list that holds all information
return(list_of_information)
}
Regression_Function(data = gala_data)
Regression_Function(data = gala_data, DV = Species, IV = c(Area, Elevation, Endemics))
Regression_Function <- function(data, DV = matrix(data[, 1]), IV = data[, 2:ncol(data)]) { ## question: how to allow IV to be any number of things
## Descriptive statistics of data:
descriptive_statistics <- "nothing for now"
## Regression coefficients, predicted values and residuals using matrix algebra:
DV <- as.matrix(DV)
IV <- as.matrix(IV)
model_coefficients  <- (solve(t(IV) %*% IV)) %*% (t(IV) %*% DV)
predicted_values <- IV %*% model_coefficients
error_residuals <- DV - predicted_values
## Simple plot of predicted values against the residuals:
simple_plot <- plot(predicted_values, error_residuals)
list_of_information <- list(descriptive_statistics, model_coefficients, predicted_values, error_residuals, simple_plot)
names(list_of_information) <- c("Descriptive statistics", "Regression coefficients", "Predicted values", "Error/Residuals",
"Simple plot of predicted values against the residuals")
## Finally, the function should return the created list that holds all information
return(list_of_information)
}
Regression_Function(data = gala_data, DV = Species, IV = c(Area, Elevation, Endemics))
View(gala_data)
Regression_Function(data = gala_data, DV = gala_data$Species, IV = c(gala_data$Area, gala_data$Elevation, gala_data$Endemics))
Regression_Function <- function(data, DV = matrix(data[, 1]), IV = data[, 2:ncol(data)]) { ## question: how to allow IV to be any number of things
## Descriptive statistics of data:
descriptive_statistics <- "nothing for now"
## Regression coefficients, predicted values and residuals using matrix algebra:
DV <- as.matrix(DV)
IV <- as.matrix(IV)
model_coefficients  <- (solve(t(IV) %*% IV)) %*% (t(IV) %*% DV)
predicted_values <- IV %*% model_coefficients
error_residuals <- DV - predicted_values
## Simple plot of predicted values against the residuals:
simple_plot <- plot(predicted_values, error_residuals)
list_of_information <- list(descriptive_statistics, model_coefficients, predicted_values, error_residuals, simple_plot)
names(list_of_information) <- c("Descriptive statistics", "Regression coefficients", "Predicted values", "Error/Residuals",
"Simple plot of predicted values against the residuals")
## Finally, the function should return the created list that holds all information
return(list_of_information)
}
Regression_Function(data = gala_data, DV = gala_data$Species, IV = c(gala_data$Area, gala_data$Elevation, gala_data$Endemics))
Regression_Function <- function(data, DV = matrix(data[, 1]), IV = data[, 2:ncol(data)]) { ## question: how to allow IV to be any number of things
## Descriptive statistics of data:
descriptive_statistics <- "nothing for now"
## Regression coefficients, predicted values and residuals using matrix algebra:
DV <- as.matrix(DV)
IV <- matrix(IV, nrow = nrow(data))
model_coefficients  <- (solve(t(IV) %*% IV)) %*% (t(IV) %*% DV)
predicted_values <- IV %*% model_coefficients
error_residuals <- DV - predicted_values
## Simple plot of predicted values against the residuals:
simple_plot <- plot(predicted_values, error_residuals)
list_of_information <- list(descriptive_statistics, model_coefficients, predicted_values, error_residuals, simple_plot)
names(list_of_information) <- c("Descriptive statistics", "Regression coefficients", "Predicted values", "Error/Residuals",
"Simple plot of predicted values against the residuals")
## Finally, the function should return the created list that holds all information
return(list_of_information)
}
Regression_Function(data = gala_data, DV = gala_data$Species, IV = c(gala_data$Area, gala_data$Elevation, gala_data$Endemics))
Regression_Function <- function(data, DV = matrix(data[, 1]), IV = data[, 2:ncol(data)]) { ## question: how to allow IV to be any number of things
## Descriptive statistics of data:
descriptive_statistics <- "nothing for now"
## Regression coefficients, predicted values and residuals using matrix algebra:
DV <- matrix(DV, nrow = nrow(data))
IV <- matrix(IV, nrow = nrow(data))
model_coefficients  <- (solve(t(IV) %*% IV)) %*% (t(IV) %*% DV)
predicted_values <- IV %*% model_coefficients
error_residuals <- DV - predicted_values
## Simple plot of predicted values against the residuals:
simple_plot <- plot(predicted_values, error_residuals)
list_of_information <- list(descriptive_statistics, model_coefficients, predicted_values, error_residuals, simple_plot)
names(list_of_information) <- c("Descriptive statistics", "Regression coefficients", "Predicted values", "Error/Residuals",
"Simple plot of predicted values against the residuals")
## Finally, the function should return the created list that holds all information
return(list_of_information)
}
Regression_Function(data = gala_data, DV = gala_data$Species, IV = c(gala_data$Area, gala_data$Elevation, gala_data$Endemics))
list(plot(gala_data$Species, gala_data$Area))
